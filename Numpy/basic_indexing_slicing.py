# -*- coding: utf-8 -*-
"""Basic_Indexing_Slicing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PKXFQ6tCcgYsItjuLTLCJvjSjk3fGuUH

# Basic

넘파이 배열 생성자
"""

import numpy as np
arr = np.array([1,2,3])
sArr = np.array(["1", "2", "3"])
bArr = np.array([0, False, ''])
print(arr)
print(sArr)
print(type(bArr[1]))
print(type(arr))

"""넘파이 배열 속성

ndim: 배열의 차원

shape : 배열의 형태 (면, 행, 열)

dtype : 원소 타입

itemsize : 원소의 할당 크기 (int32 4byte)

size : 원소의 개수
"""

print(arr)
print(arr.ndim, arr.shape, arr.dtype, arr.itemsize, arr.size)
print()
arr2 = np.array([[i + j * 10 for i in range(1, 11)] for j in range(5)])
print(arr2)
print(arr2.ndim, arr2.shape, arr2.dtype, arr2.itemsize, arr2.size)
print()

arr3 = np.array([[[i + j * 10 + z * 50 + 1 for i in range(5)] for j in range(5)] for z in range(5)])
print(arr3)
print(arr3.ndim, arr3.shape, arr3.dtype, arr3.itemsize, arr3.size)

"""브로드 캐스팅

 - 모든 원소에 값과 산술연산 적용한 배열 반환
"""

arr = np.array([1,3,5])
arr += 1 # [1 + 1, 3 + 1, 5 + 1]
print(arr)

arr **= 2 # [2 ** 2, 4 ** 2, 6 ** 2]
print(arr)

"""벡터화 연산
- 리스트 + 리스트 : 연결 연산
- 넘파이 + 넘파이 : 원소별 연산
"""

lst1 = [1,2,3]
lst2 = [2,4,6]
print(lst1 + lst2, '연결 연산')

np1 = np.array(lst1)
np2 = np.array(lst2)
print(np1 + np2, '벡터화 연산')

"""행렬 곱셈
 - (x, y) 배열 @ (y, z) 배열 -> (x, z) 배열 반환
"""

x = np.array([[i + j * 3 for i in range(1, 4)] for j in range(3)])
y = np.array([[i + j * 4 for i in range(1, 5)] for j in range(3)])
print(x.shape)
print(y.shape)
print(x)
print(y)
print(x @ y)
z = [[1 + 10 + 27, 2 + 12 + 30, 3 + 14 + 33, 4 + 16 + 36],
[4 + 25 + 54, 8 + 30 + 60, 12 + 35 + 66, 16 + 40 + 72],
[7 + 40 + 81, 14 + 48 + 90, 21 + 56 + 99, 28 + 64 + 108]]
z = np.array(z)
print(z)
print(x @ y == z)

# BMI 계산
height = [1.83, 1.75, 1.71, 1.78, 1.85, 1.77, 1.73]
weight = [80, 74, 59, 77, 90, 77, 78]
h = np.array(height)
w = np.array(weight)
bmi = w / h ** 2
print(bmi)

result = [ weight[i] / height[i] ** 2 for i in range(len(height)) ]
result2 = list(map(lambda x : x[0] / x[1] ** 2, zip(weight, height)))
print(result)
print(bmi == np.array(result))
print(bmi == np.array(result2))

"""# indexing, slicing

넘파이 배열의 인덱싱은 정수, 배열, 논리 인덱싱 가능
"""

arr = np.array([1,2,3,4,5])
n = arr.size

# indexing
print(arr[0])
print(arr[-1], arr[n - 1])

# slicing
print(arr[1 : 4])
print(arr[0 : -1]) # 마지막 원소 제외
print(arr[:], arr[0:], arr[:n], arr[0:n])

"""2차원 정수 인덱싱
 - [정수, 정수] : 1차원 배열
 - [정수, 슬라이싱] : 1차원 배열
 - [슬라이싱, 슬라이싱] : 2차원 배열 반환
"""

arr2 = np.array([[i + j * 10 for i in range(1, 11)] for j in range(10)])
print(arr2[0, :])
print(arr2[1:2, :])
print(arr2[:, 1::2]) # 모든 행 중에 1번 열부터 2칸 씩

"""배열 인덱싱
- np_arr = [1,2,3,4]
- np_arr[[0,2,1]] : [1,3,2]
"""

print(arr[[0, 3, 2, 4]]) # 배열을 인덱싱으로 사용 가능

"""논리 배열 생성
- boolean = np.array >= n : 논리 배열 반환
- 2차원 arr[2차원 논리배열] : 1차원 배열 반환
- 2차원 arr[1차원 논리배열] : 2차원 배열 반환
"""

larr = arr >= 3
print(larr)
print(arr[larr]) # 3보다 크거나 같은 원소만 가져옴

larr = arr2 % 3 == 0
print(arr2[larr])

# 2차원 논리 인덱싱
larr = arr2 % 2 == 0
print('모든 요소 중 짝수인 요소만 골라 1차원 배열로 반환')
print(arr2[larr]) # 1차원 배열로 반환됨

print("\n모든 행의 첫 번째 요소의 10의자리 수가 짝수인 행만 출력")
larr = arr2[:, 0] // 10 % 2 == 0
print(larr) # 1차원 배열 (각 행에 대한 boolean형)
print(arr2[larr])

"""실습. 2차원 배열에서 조건 만족 행 추출"""

lst = np.array([
    [177, 77.1],
    [182, 80.2],
    [185, 102.5],
    [178, 77.6],
    [163, 60.2],
    [166, 52.6],
    [171, 62.6],
])

print("몸무게가 60이상")
print(lst[ lst[:, 1] >= 60 ])

print("\n키가 170보다 작은사람")
print(lst[ lst[:, 0] < 170])

print("\n키가 180보다 작고 몸무게가 60 이상인사람")
harr = lst[:, 0] < 180
warr = lst[:, 1] >= 60
larr = harr == warr
print(lst[larr])